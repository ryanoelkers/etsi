""" This set of functions is primarily used for photometery."""
from config import Configuration
from libraries.utils import Utils
from photutils import CircularAperture
from photutils import CircularAnnulus
from photutils import aperture_photometry
from photutils import RectangularAperture
from photutils.detection import find_peaks
from photutils.detection import DAOStarFinder
from photutils.psf import extract_stars
from photutils.psf import EPSFBuilder
import os
from astropy.stats import sigma_clipped_stats
from astropy.table import Table
from astropy.nddata import NDData
from astropy.io import fits
import numpy as np
import pandas as pd
import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", category=Warning)
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt


class Photometry:

    @staticmethod
    def single_frame_psf_photometry(img, file_name):
        """ This function will perform PSF photometry on given images.

        :parameter img - The image file
        :parameter file_name - The name of the output file for the flux generated by the frame

        """
        # get the sky background as the median of the image
        sky_mean, sky_median, sky_sigma = sigma_clipped_stats(img)
        sky_threshold = sky_median + 100 * sky_sigma
        Utils.log("The image sky background is " + str(int(np.around(sky_median, decimals=0))) + "+/-" +
                  str(int(np.around(sky_sigma, decimals=0))) + " ADU.", "info")

        # get the peaks in  the image
        Utils.log("Determining star peaks...", "info")
        peaks_tbl = find_peaks(img, sky_threshold, box_size=[Configuration.PSF_X, Configuration.PSF_Y])

        # pull out the x/y pixel positions
        x_pix = peaks_tbl['x_peak']
        y_pix = peaks_tbl['y_peak']

        # mask pixels within a tolerance of the edge
        mask = ((x_pix > Configuration.PSF_EDGE_LIMIT) & (x_pix < (img.shape[1] - 1 - Configuration.PSF_EDGE_LIMIT)) &
                (y_pix > Configuration.PSF_EDGE_LIMIT) & (y_pix < (img.shape[0] - 1 - Configuration.PSF_EDGE_LIMIT)))

        # generate a stars table
        stars_tbl = Table()
        stars_tbl['x'] = x_pix[mask]
        stars_tbl['y'] = y_pix[mask]

        # background subtract the image
        img_bsub = img - sky_median
        img_nddata = NDData(data=img_bsub)

        # get individual star objects
        stars = extract_stars(img_nddata, stars_tbl, size=(Configuration.PSF_Y + Configuration.PSF_BUFFER,
                                                           Configuration.PSF_X + Configuration.PSF_BUFFER))

        # build the PSF
        Utils.log("Building PSF...", "info")
        epsf_builder = EPSFBuilder(oversampling=4, maxiters=10)
        epsf, fitted_stars = epsf_builder(stars)
        fits.writeto('hmm.fits', epsf.data, overwrite=True)
        print('hold')


    @staticmethod
    def single_frame_star_finder(img):
        """ This function will find the stars on the image and find their particular centroids.

        :parameter img - The image where the finder will look for stars

        :return star_list - The star list is returned
        """

        # get the statistics on the image to provide the sky background
        mean_sky, median_sky, std_sky = sigma_clipped_stats(img, sigma=2.5)

        # find the stars on the image with DAOfind
        daofind = DAOStarFinder(fwhm=Configuration.FWHM,
                                threshold=Configuration.THRESHOLD * std_sky)
        sources = daofind(img-median_sky)

        # move the sources into a dataframe for ease of use down the line
        star_list = pd.DataFrame(columns=['id', 'x', 'y'])
        star_list['x'] = np.array(sources['xcentroid'])
        star_list['y'] = np.array(sources['ycentroid'])
        star_list['id'] = np.array(sources['id'])

        return star_list

    @staticmethod
    def single_frame_aper(star_list, img, file_name, flux_only='N', bkg_sub='global'):
        """" This function will perform aperture photometry on a single frame.

        :parameter star_list - The list of stars to perform the photometry
        :parameter img - The image where photometry will be performed
        :parameter file_name - The file name for the output flux file
        :parameter flux_only - Y/N if you only want the flux to be generated by the code
        :parameter bkg_sub - global/local/diff if you want to subtract the local background,
                the median image background, or if the frame is from a differenced image

        :return star_list - The star_list data frame is returned with the flux/mag values and errors included
        """

        # generate the positions of the stars
        positions = star_list[['x', 'y']].values.tolist()
        star_list['xm_rect'] = star_list.apply(lambda x: x.x - (Configuration.APER_SIZE / 2), axis=1)
        star_list['xp_rect'] = star_list.apply(lambda x: x.x + (Configuration.APER_SIZE / 2), axis=1)
        positions_mrect = star_list[['xm_rect', 'y']].values.tolist()
        positions_prect = star_list[['xp_rect', 'y']].values.tolist()
        # run aperture photometry
        # set up the star aperture and sky annuli
        aperture = CircularAperture(positions, r=Configuration.APER_SIZE)
        aperture_mrect = RectangularAperture(positions_mrect, Configuration.APER_SIZE, Configuration.APER_SIZE * 2)
        aperture_prect = RectangularAperture(positions_prect, Configuration.APER_SIZE, Configuration.APER_SIZE * 2)
        annulus_aperture = CircularAnnulus(positions, r_in=Configuration.ANNULI_INNER, r_out=Configuration.ANNULI_OUTER)
        apers = [aperture, annulus_aperture]
        # apers_rect = [aperture_mrect, aperture_prect]

        # run the photometry to get the data table
        phot_table = aperture_photometry(img, apers, method='exact')
        phot_table_mrect = aperture_photometry(img, aperture_mrect, method='exact')
        phot_table_prect = aperture_photometry(img, aperture_prect, method='exact')

        # extract the sky background for each annuli based on either a global or local subtraction
        star_list['local_sky'] = phot_table['aperture_sum_1'] / annulus_aperture.area
        if bkg_sub == 'local':
            sky = phot_table['aperture_sum_1'] / annulus_aperture.area
            bkg = sky * aperture.area
            bkg_mrect = sky * aperture_mrect.area
            bkg_prect = sky * aperture_prect.area
        elif bkg_sub == 'global':
            sky = np.median(img)
            bkg = sky * aperture.area
            bkg_mrect = sky * aperture_mrect.area
            bkg_prect = sky * aperture_prect.area
        else:
            sky = 0
            bkg = sky
            bkg_mrect = sky * aperture_mrect.area
            bkg_prect = sky * aperture_prect.area

        # subtract the sky background to get the stellar flux and square root of total flux to get the photometric error
        star_list['flux'] = np.array(phot_table['aperture_sum_0'] - bkg)
        star_list['m_flux'] = np.array(phot_table_mrect['aperture_sum'] - bkg_mrect)
        star_list['p_flux'] = np.array(phot_table_prect['aperture_sum'] - bkg_prect)

        # calculate the expected photometric error
        star_error = np.sqrt((phot_table['aperture_sum_0'] - bkg) * Configuration.GAIN)
        sky_error = np.sqrt(aperture.area * sky * Configuration.GAIN)

        # combine sky and signal error in quadrature
        star_list['flux_err'] = np.array(np.sqrt(star_error ** 2 + sky_error ** 2))

        if flux_only == 'N':
            # convert to magnitude
            star_list['mag'] = 25. - 2.5 * np.log10(star_list['flux'].to_numpy())
            star_list['mag_err'] = (np.log(10.) / 2.5) * (star_list['flux_err'].to_numpy() /
                                                          star_list['flux'].to_numpy())

            star_list['m_mag'] = 25. - 2.5 * np.log10(star_list['m_flux'].to_numpy())
            star_list['p_mag'] = 25. - 2.5 * np.log10(star_list['p_flux'].to_numpy())

        star_list = star_list[(star_list['flux'] > 0) &
                              (star_list['m_flux'] > 0) &
                              (star_list['p_flux'] > 0)].reset_index(drop=True)
        star_list.to_csv(file_name + '.flux')
        return star_list

    @staticmethod
    def get_star_list(directory, files):
        """ This function will read in all flux files and sort the star lists to make sure the light curves
        have the right data associated with them.

        :parameter directory - The directory with the flux files
        :parameter files - The file name of each flux file
        """
        # read in the first image, assume this is the correct set of stars
        flux_df_org = pd.read_csv(directory + files[0], sep=',', header=0)
        flux_df_org = flux_df_org[flux_df_org['flux'] > 10000].reset_index(drop=True)

        mags = np.zeros((len(flux_df_org), len(files)))
        pmags = np.zeros((len(flux_df_org), len(files)))
        mmags = np.zeros((len(flux_df_org), len(files)))
        mags[:, 0] = flux_df_org['flux'].to_numpy()
        pmags[:, 0] = flux_df_org['p_flux'].to_numpy()
        mmags[:, 0] = flux_df_org['m_flux'].to_numpy()

        for idx, file in enumerate(files[1:]):

            # read in the flux file
            flux_df = pd.read_csv(directory + file, sep=',', header=0)

            # for each star check which index is which
            for idy, row in flux_df_org.iterrows():
                flux_df['dist_off'] = np.sqrt((flux_df['x'] - row['x']) ** 2 + (flux_df['y'] - row['y']) ** 2)
                flux_df['mag_off'] = np.abs(flux_df['mag'] - row['mag'])

                if (flux_df.dist_off.min() < 100) & \
                        (flux_df[flux_df.dist_off == flux_df.dist_off.min()]['mag_off'].values[0] < 0.5):
                    mags[idy, idx + 1] = flux_df[flux_df.dist_off == flux_df.dist_off.min()]['flux']
                    mmags[idy, idx + 1] = flux_df[flux_df.dist_off == flux_df.dist_off.min()]['m_flux']
                    pmags[idy, idx + 1] = flux_df[flux_df.dist_off == flux_df.dist_off.min()]['p_flux']
                else:
                    print('hold')
        print('hold')

    @staticmethod
    def combine_flux_files(directory, files):
        """ This function combines all of the flux files in a given directory into a single data frame.

        :parameter directory - The directory where the files are located
        :parameter files - A list of the files

        :returns data_df - A large data frame with all of the stellar flux information
        """

        # loop through the flux files, converting the flux to magnitude and then adding to the previous file
        for idx in range(0, nstars, num_rrows):

            Utils.log("Now working to create the raw light curves for Sector: " + Configuration.SECTOR +
                      " Camera: " + Configuration.CAMERA + " CCD:" + Configuration.CCD + ". Getting stars " +
                      str(idx) + " to " + str(num_rrows+idx) + ".", "info", Configuration.LOG_SCREEN)

            # update num_rrows if needed
            if nstars - idx < num_rrows:
                num_rrows = nstars - idx

            # make the holders for the light curves
            date = np.zeros(len(files))
            mags = np.zeros((len(files), num_rrows)) - 99.00
            clns = np.zeros((len(files), num_rrows)) - 99.00
            errs = np.zeros((len(files), num_rrows)) - 99.00

            for idy, file in enumerate(files):

                # read in the flux file
                if idx == 0:
                    flux_df = pd.read_csv(directory + file, sep=' ', index_col='TICID', header=0, nrows=num_rrows)
                if idx > 0:
                    flux_df = pd.read_csv(directory + file, sep=' ', index_col='TICID',
                                          header=0, skiprows=range(1, idx+1), nrows=num_rrows)

                # combine with the master frame photometry
                full_df = pd.merge(flux_df, master_df, on='TICID', how='left', suffixes=['', '_mast']).reset_index()

                # set the date
                date[idy] = full_df['JD'].iloc[0]

                # calculate the magnitudes
                mags[idy, :] = full_df['mag'].to_numpy()

                # calculate the clean magnitudes
                clns[idy, :] = full_df['clean'].to_numpy()

                # calculate the errors
                errs[idy, :] = full_df['mag_err'].to_numpy()

            # get the TICIDs for writing the light curves
            tics = full_df.TICID.to_numpy()

            # now write hte light curves
            Photometry.write_light_curves(tics, date, mags, clns, errs)

        return

    @staticmethod
    def write_light_curves(tics, date, mags, clns, errs):
        """ This function will write the times, magnitudes and errors to files.

        :parameter tics - The TICIDs for the current set of stars
        :parameter date - The dates for the light curves
        :parameter mags - The magnitudes for the light curves
        :parameter clns - The cleaned magnitude for the light curve
        :parameter errs - The errors in the light curves.

        :return - Nothing is returned, but the light curve files are written
        """

        # initialize the light curve data frame
        lc = pd.DataFrame(columns={'JD', 'clean', 'mag', 'err'})

        for idx, ticid in enumerate(tics):

            if (idx % 10000 == 0) and (idx > 0):
                Utils.log("10,000 light curves written for sector: " + str(Configuration.SECTOR) +
                          " Camera: " + str(Configuration.CAMERA) + " CCD: " + str(Configuration.CCD) +
                          ". Writing the next 10,000, " + str(len(tics) - idx - 1) +
                          " light curves remain to be written.", "info", Configuration.LOG_SCREEN)

            # add the time, magnitude and error to the data frame
            lc['JD'] = np.around(date, decimals=6)
            lc['clean'] = np.around(clns[:, idx], decimals=6)
            lc['mag'] = np.around(mags[:, idx], decimals=6)
            lc['err'] = np.around(errs[:, idx], decimals=6)

            # write the data to a text file
            if os.path.exists(Configuration.RAW_LC_DIRECTORY + str(ticid) + "_" + str(Configuration.SECTOR) + "_" +
                              str(Configuration.CAMERA) + "_" + str(Configuration.CCD) + ".lc"):
                os.system('rm -f ' + Configuration.RAW_LC_DIRECTORY + str(ticid) + "_" + str(Configuration.SECTOR) +
                          "_" + str(Configuration.CAMERA) + "_" + str(Configuration.CCD) + ".lc")

            # write the new file
            lc[['JD', 'clean', 'mag', 'err']].to_csv(Configuration.RAW_LC_DIRECTORY + str(ticid) + "_" +
                                                     str(Configuration.SECTOR) + "_" +
                                                     str(Configuration.CAMERA) + "_" +
                                                     str(Configuration.CCD) + ".lc",
                                                     sep=" ", header=False, index=False, na_rep='9.999999')

        return
