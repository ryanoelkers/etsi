""" This set of functions is primarily used for photometery."""
from config import Configuration
from libraries.utils import Utils
from astropy.io import fits
from PyAstronomy import pyasl
from astropy import time
from dateutil import parser
from photutils import CircularAperture
from photutils import CircularAnnulus
from photutils import aperture_photometry
from photutils import RectangularAperture
from photutils import RectangularAnnulus
from photutils import EllipticalAperture
from photutils import EllipticalAnnulus
from photutils.centroids import centroid_sources
from photutils.psf import IntegratedGaussianPRF, DAOGroup, BasicPSFPhotometry
from photutils.background import MMMBackground
from astropy.modeling.fitting import LevMarLSQFitter
from astropy.stats import gaussian_sigma_to_fwhm
import os
from astropy.table import Table
import numpy as np
import pandas as pd
import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", category=Warning)
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt


class Photometry:

    @staticmethod
    def single_frame_psf_photometry(star_list, img, file_name, flux_only='N'):
        """ This function will perform PSF photometry on given images.

        :parameter img - The image file
        :parameter file_name - The name of the output file for the flux generated by the frame

        """
        # set up column names for later
        exs = ['x1', 'x2', 'x3', 'x4']
        wys = ['y1', 'y2', 'y3', 'y4']
        flx = ['flux1', 'flux2', 'flux3', 'flux4']
        flxe = ['fluxe1', 'fluxe2', 'fluxe3', 'fluxe4']
        mag = ['mag1', 'mag2', 'mag3', 'mag4']
        mage = ['mage1', 'mage2', 'mage3', 'mage4']

        # set up DAOGROUPS
        daogroup = DAOGroup(2.0 * Configuration.SIGMA_PSF * gaussian_sigma_to_fwhm)
        mmm_bkg = MMMBackground()

        # generate a Gaussian PSF
        psf_model = IntegratedGaussianPRF(sigma=Configuration.SIGMA_PSF)

        # use fixed positions
        psf_model.x_0.fixed = True
        psf_model.y_0.fixed = True
        photometry = BasicPSFPhotometry(group_maker=daogroup, bkg_estimator=mmm_bkg, psf_model=psf_model,
                                        fitter=LevMarLSQFitter(), fitshape=(Configuration.PSF_X, Configuration.PSF_Y))

        for st in range(0, Configuration.NUM_PSF):
            # pull positions from the xy_list
            pos = Table(names=['x_0', 'y_0'], data=[star_list[exs[st]], star_list[wys[st]]])

            # run the photometry
            phot_table = photometry(image=img, init_guesses=pos)

            # subtract the sky background to get the stellar flux and square root of total flux to get the photometric error
            star_list[flx[st]] = np.array(phot_table['flux_fit'])

            # calculate the expected photometric error
            star_list[flxe[st]] = np.array(phot_table['flux_unc'])

            if flux_only == 'N':
                # convert to magnitude
                star_list[mag[st]] = 25. - 2.5 * np.log10(star_list[flx[st]].to_numpy())
                star_list[mage[st]] = (np.log(10.) / 2.5) * (star_list[flxe[st]].to_numpy() /
                                                             star_list[flx[st]].to_numpy())

        # output the flux files
        star_list.to_csv(file_name + '_' + Configuration.PHOTOMETRY + '.flux')

        return star_list[star_list.index == 0]

    @staticmethod
    def force_position(img, xy_list):
        """ This function will force the xy positions based on hand selections and use the expectation for the
        PSF positions based on the theory. The function updates the initial positions based on centroiding and then
        sends out the PSF positions.

        :parameter img - The image where the finder will look for stars
        :parameter xy_list - The hand selection positions

        :return star_list - The list of star positions
        """

        # get the centroids based on the initial xy_list
        x_cen_st1, y_cen_st1 = centroid_sources(img, xy_list.x.to_numpy(), xy_list.y.to_numpy(),
                                                box_size=[Configuration.ELIP_APER_B, Configuration.ELIP_APER_A])

        # move the star based on the theoretical PSF and then re-centroid for PSF 2
        x_cen_st2, y_cen_st2 = centroid_sources(img, xy_list.x.to_numpy() + Configuration.ST2, xy_list.y.to_numpy(),
                                                box_size=[Configuration.ELIP_APER_B, Configuration.ELIP_APER_A])

        # move the star based on the theoretical PSF and then re-centroid for PSF 3
        x_cen_st3, y_cen_st3 = centroid_sources(img, xy_list.x.to_numpy() + Configuration.ST3, xy_list.y.to_numpy(),
                                                box_size=[Configuration.ELIP_APER_B, Configuration.ELIP_APER_A])

        # move the star based on the theoretical PSF and then re-centroid for PSF 4
        x_cen_st4, y_cen_st4 = centroid_sources(img, xy_list.x.to_numpy() + Configuration.ST4, xy_list.y.to_numpy(),
                                                box_size=[Configuration.ELIP_APER_B, Configuration.ELIP_APER_A])

        # update the star list and add the updated positions
        star_list = xy_list.copy().reset_index(drop=True)
        star_list['x1'] = x_cen_st1
        star_list['y1'] = y_cen_st1
        star_list['x2'] = x_cen_st2
        star_list['y2'] = y_cen_st2
        star_list['x3'] = x_cen_st3
        star_list['y3'] = y_cen_st3
        star_list['x4'] = x_cen_st4
        star_list['y4'] = y_cen_st4

        return star_list

    @staticmethod
    def single_frame_aperture_photometry(star_list, img, file_name, flux_only='N', bkg_sub='global'):
        """" This function will perform aperture photometry on a single frame.

        :parameter star_list - The list of stars to perform the photometry
        :parameter img - The image where photometry will be performed
        :parameter file_name - The file name for the output flux file
        :parameter flux_only - Y/N if you only want the flux to be generated by the code
        :parameter bkg_sub - global/local/diff if you want to subtract the local background,
                the median image background, or if the frame is from a differenced image

        :return star_list - The star_list data frame is returned with the flux/mag values and errors included
        """

        # set up column names for later
        exs = ['x1', 'x2', 'x3', 'x4']
        wys = ['y1', 'y2', 'y3', 'y4']
        flx = ['flux1', 'flux2', 'flux3', 'flux4']
        flxe = ['fluxe1', 'fluxe2', 'fluxe3', 'fluxe4']
        mag = ['mag1', 'mag2', 'mag3', 'mag4']
        mage = ['mage1', 'mage2', 'mage3', 'mage4']
        lsky = ['lsky1', 'lsky2', 'lsky3', 'lsky4']

        for st in range(0, Configuration.NUM_PSF):
            # generate the positions of the stars
            positions = star_list[[exs[st], wys[st]]].values.tolist()

            # set up the appropraite aperture sizes
            if Configuration.APERTURE_SHAPE == 'circle':

                aperture = CircularAperture(positions, r=Configuration.CIRC_APER_SIZE)
                aperture_annulus = CircularAnnulus(positions,
                                                   r_in=Configuration.CIRC_ANNULI_INNER,
                                                   r_out=Configuration.CIRC_ANNULI_OUTER)
                apers = [aperture, aperture_annulus]
            elif Configuration.APERTURE_SHAPE == 'rectangle':
                aperture = RectangularAperture(positions, Configuration.RECT_APER_W, Configuration.RECT_APER_H)
                aperture_annulus = RectangularAnnulus(positions,
                                                      w_in=Configuration.RECT_ANNULI_W0,
                                                      w_out=Configuration.RECT_ANNULI_WN,
                                                      h_in=Configuration.RECT_ANNULI_H0,
                                                      h_out=Configuration.RECT_ANNULI_HN)
                apers = [aperture, aperture_annulus]
            else:
                aperture = EllipticalAperture(positions, Configuration.ELIP_APER_A, Configuration.ELIP_APER_B)
                aperture_annulus = EllipticalAnnulus(positions,
                                                     a_in=Configuration.ELIP_ANNULI_A0,
                                                     a_out=Configuration.ELIP_ANNULI_AN,
                                                     b_in=Configuration.ELIP_ANNULI_B0,
                                                     b_out=Configuration.ELIP_ANNULI_BN)
                apers = [aperture, aperture_annulus]

            # run the photometry to get the data table
            phot_table = aperture_photometry(img, apers, method='exact')

            # extract the sky background for each annuli based on either a global or local subtraction
            star_list[lsky[st]] = phot_table['aperture_sum_1'] / aperture_annulus.area

            if bkg_sub == 'local':
                sky = phot_table['aperture_sum_1'] / aperture_annulus.area
            elif bkg_sub == 'global':
                sky = np.median(img)
            else:
                sky = 0

            # subtract the sky background to get the stellar flux and square root of total flux to get the photometric error
            star_list[flx[st]] = np.array(phot_table['aperture_sum_0'] - sky)

            # calculate the expected photometric error
            star_error = np.sqrt((phot_table['aperture_sum_0'] - sky) * Configuration.GAIN)
            sky_error = np.sqrt(aperture.area * sky * Configuration.GAIN)

            # combine sky and signal error in quadrature
            star_list[flxe[st]] = np.array(np.sqrt(star_error ** 2 + sky_error ** 2))

            if flux_only == 'N':
                # convert to magnitude
                star_list[mag[st]] = 25. - 2.5 * np.log10(star_list[flx[st]].to_numpy())
                star_list[mage[st]] = (np.log(10.) / 2.5) * (star_list[flxe[st]].to_numpy() /
                                                             star_list[flx[st]].to_numpy())

        # output the flux files
        star_list.to_csv(file_name + '_'+ Configuration.PHOTOMETRY + '.flux')

        return star_list[star_list.index == 0]

    @staticmethod
    def combine_flux_files(directory, files):
        """ This function combines all of the flux files in a given directory into a single data frame.

        :parameter directory - The directory where the files are located
        :parameter files - A list of the image files

        :returns data_df - A large data frame with all of the stellar flux information
        """

        star_list = pd.read_csv(Configuration.CENTROID_DIRECTORY + files[0].split('.')[0] + '_list.txt',
                                delimiter=' ', names=['x', 'y'])
        num_rrows = len(star_list)

        # make the holders for the light curves
        jdte = np.zeros(len(files))
        hjdte = np.zeros(len(files))
        phse = np.zeros(len(files))

        psf_flx1 = np.zeros((len(files), num_rrows)) - 99.00
        psf_flx2 = np.zeros((len(files), num_rrows)) - 99.00
        psf_flx3 = np.zeros((len(files), num_rrows)) - 99.00
        psf_flx4 = np.zeros((len(files), num_rrows)) - 99.00

        apr_flx1 = np.zeros((len(files), num_rrows)) - 99.00
        apr_flx2 = np.zeros((len(files), num_rrows)) - 99.00
        apr_flx3 = np.zeros((len(files), num_rrows)) - 99.00
        apr_flx4 = np.zeros((len(files), num_rrows)) - 99.00

        x1 = np.zeros((len(files), num_rrows)) - 99.00
        x2 = np.zeros((len(files), num_rrows)) - 99.00
        x3 = np.zeros((len(files), num_rrows)) - 99.00
        x4 = np.zeros((len(files), num_rrows)) - 99.00

        y1 = np.zeros((len(files), num_rrows)) - 99.00
        y2 = np.zeros((len(files), num_rrows)) - 99.00
        y3 = np.zeros((len(files), num_rrows)) - 99.00
        y4 = np.zeros((len(files), num_rrows)) - 99.00

        for idy, file in enumerate(files):

            if os.path.isfile(directory + file.split('.')[0] + '_psf.flux') & \
                    os.path.isfile(directory + file.split('.')[0] + '_APER.flux'):

                if (idy % 100) == 0:
                    Utils.log("Read in 100 flux files. " + str(len(files)-idy-1) + " files remain.", "info")
                # get the time and phase information
                header = fits.getheader(Configuration.CLEAN_DIRECTORY + file)
                dt = parser.parse(header['DATE-OBS'])
                tm = time.Time(dt)
                jdte[idy] = tm.jd
                hjdte[idy] = pyasl.helio_jd(jdte[idy] - 2.4e6, Configuration.RA, Configuration.DEC) + 2.4e6
                phse[idy] = ((jdte[idy] - Configuration.TC) / Configuration.PERIOD) % 1
                if phse[idy] > 0.5:
                    phse[idy] = phse[idy] - 1

                psf_df = pd.read_csv(directory + file.split('.')[0] + '_PSF.flux', sep=',', index_col=0)
                apr_df = pd.read_csv(directory + file.split('.')[0] + '_APER.flux', sep=',', index_col=0)

                # PSF flux arrays
                psf_flx1[idy, :] = psf_df['flux1'].to_numpy()
                psf_flx2[idy, :] = psf_df['flux2'].to_numpy()
                psf_flx3[idy, :] = psf_df['flux3'].to_numpy()
                psf_flx4[idy, :] = psf_df['flux4'].to_numpy()

                # APER flux arrays
                apr_flx1[idy, :] = apr_df['flux1'].to_numpy()
                apr_flx2[idy, :] = apr_df['flux2'].to_numpy()
                apr_flx3[idy, :] = apr_df['flux3'].to_numpy()
                apr_flx4[idy, :] = apr_df['flux4'].to_numpy()

                # x arrays
                x1[idy, :] = apr_df['x1'].to_numpy()
                x2[idy, :] = apr_df['x2'].to_numpy()
                x3[idy, :] = apr_df['x3'].to_numpy()
                x4[idy, :] = apr_df['x4'].to_numpy()

                # y arrays
                y1[idy, :] = apr_df['y1'].to_numpy()
                y2[idy, :] = apr_df['y2'].to_numpy()
                y3[idy, :] = apr_df['y3'].to_numpy()
                y4[idy, :] = apr_df['y4'].to_numpy()

        # now write hte light curves
        Photometry.write_light_curves(num_rrows, jdte, hjdte, phse,
                                      x1, y1, psf_flx1, apr_flx1,
                                      x2, y2, psf_flx2, apr_flx2,
                                      x3, y3, psf_flx3, apr_flx3,
                                      x4, y4, psf_flx4, apr_flx4)

        return

    @staticmethod
    def write_light_curves(nstars, jd, hjd, ph, x1, y1, pf1, af1, x2, y2, pf2, af2, x3, y3, pf3, af3, x4, y4, pf4, af4):
        """ This function will write the ETSI columns to a text file for later

        :return - Nothing is returned, but the light curve files are written
        """

        # initialize the light curve data frame
        lc = pd.DataFrame(columns={'jd', 'hjd', 'ph',
                                   'x1', 'y1', 'psf1', 'apr1',
                                   'x2', 'y2', 'psf2', 'apr2',
                                   'x3', 'y3', 'psf3', 'apr3',
                                   'x4', 'y4', 'psf4', 'apr4'})

        Utils.log("Starting light curve writing...", "info")

        for idx in range(0, nstars):
            if idx >= 10:
                star_id = str(idx)
            else:
                star_id = '0' + str(idx)

            # add the time, magnitude and error to the data frame
            lc['jd'] = np.around(jd, decimals=6)
            lc['hjd'] = np.around(hjd, decimals=6)
            lc['ph'] = np.around(ph, decimals=6)
            lc['psf1'] = np.around(pf1[:, idx], decimals=6)
            lc['psf2'] = np.around(pf2[:, idx], decimals=6)
            lc['psf3'] = np.around(pf3[:, idx], decimals=6)
            lc['psf4'] = np.around(pf4[:, idx], decimals=6)
            lc['apr1'] = np.around(af1[:, idx], decimals=6)
            lc['apr2'] = np.around(af2[:, idx], decimals=6)
            lc['apr3'] = np.around(af3[:, idx], decimals=6)
            lc['apr4'] = np.around(af4[:, idx], decimals=6)
            lc['x1'] = np.around(x1[:, idx], decimals=6)
            lc['x2'] = np.around(x2[:, idx], decimals=6)
            lc['x3'] = np.around(x3[:, idx], decimals=6)
            lc['x4'] = np.around(x4[:, idx], decimals=6)
            lc['y1'] = np.around(y1[:, idx], decimals=6)
            lc['y2'] = np.around(y2[:, idx], decimals=6)
            lc['y3'] = np.around(y3[:, idx], decimals=6)
            lc['y4'] = np.around(y4[:, idx], decimals=6)

            # write the new file
            lc[['jd', 'hjd', 'ph',
                'x1', 'y1', 'psf1', 'apr1',
                'x2', 'y2', 'psf2', 'apr2',
                'x3', 'y3', 'psf3', 'apr3',
                'x4', 'y4', 'psf4', 'apr4']][lc['apr1'] != -99.000000].to_csv(Configuration.LIGHTCURVE_DIRECTORY +
                                                                              Configuration.STAR + '_' +
                                                                              star_id + ".lc",
                                                                              sep=" ", index=False, na_rep='9.999999')

        return
